# 1. 事务管理

Spring框架为事务管理提供了一致性的抽象，具有以下优点：

* 跨不同事务API的一致性编程模型，例如Java Transaction API(JTA)，JDBC，Hibernate，Java Persistence API(JPA)。

* 提供声明式事务管理。

* 为编程事务管理提供比复杂事务管理API（例如JTA）更简单的API。

* 与Spring的数据访问抽象的出色集成。



以下部分描述了Spring框架的事务特性和技术：

* Spring框架事务支持模型的优点：描述了为什么可以使用Spring框架事务抽象来代替EJB容器管理事务或选择通过专用API驱动本地事务 ，例如Hibernate。

* 理解Spring框架的事务抽象：列出核心类，并描述如何配置并从多种源中获取`DataSource`实例。

* 将资源与事务同步：描述了应用程序代码如何确保正确创建、重用和清理资源。

* 声明式事务管理：描述了对声明式事务的支持。

* 编程事务管理：涵盖可编程的支持。

* 事务绑定事件：描述了如何在事务中使用应用程序事件。



## 1.1. Spring框架事务支持模型的优点

传统上，Java EE开发者对于事务管理来说有两个选择：全局或本地事务，两者都有很大的局限性。下节将回顾全局和本地事务管理类，随后讨论Spring框架事务管理如何解决全局和本地事务模型的局限性。



### 1.1.1. 全局事务

全局事务可以让用户使用多种事务资源，通常是关系型数据库和消息队列。应用程序服务通过JTA管理全局事务，它很繁琐（部分是由于异常模型）。此外，JTA `UserTransaction`通常来源于JNDI，这意味着还需要使用JNDI才能使用JTA。全局事务的使用限制了任何应用程序代码的潜在的重用能力，因为JTA通常仅在应用程序服务环境中可用。



以前，使用全局事务的首选方法是通过EJB CMT(Container Managed Transaction)。CMT是声明式事务管理的一种形式（与程序性事务管理不同）。EJB CMT移除了与事务相关的JNDI查找需要，尽管使用EJB本身需要JNDI。它消除了大多数但不是全部的通过Java代码来控制事务的需要。一个重要的缺点是，CMT与JTA和应用程序服务器环境相关联。此外，如果选择使用EJBs实现业务逻辑，它是唯一可用的。通常，EJB的缺点很大，以至于这不是一个有吸引力的提议，特别是面对声明式事务管理的强制选择时。



### 1.1.2. 本地事务

本地事务是特殊的资源，例如与JDBC相关连的事务。本地事务可能使用更简单，但是有一个重要的缺点：他们不能在跨多个事务资源上工作。例如，使用JDBC连接管理的事务代码不能在全局JTA事务中运行。因为应用服务器不参与事务管理，它不能确保多个资源之间的正确性。（值得注意的是，大多数应用程序使用单个事务资源。）另一个缺点是本地事务对编程模型具有侵入性。



### 1.1.3. Spring框架的一致性事务模型

Spring解决了全局和本地事务的缺点。它让开发者能在任何环境中使用一致的编程模型。只需要写一次代码，就可以从不同环境中的不同事务策略中受益。Spring提供声明和编程事务管理。多数用户更喜欢声明式事务管理，这也是在多数情况下建议使用的。



通过编程事务管理，开发人员可以使用Spring框架事务抽象，该抽象可以在任何基于事务基础框架下正常工作。使用首选的声明式事务模型，开发人员通常只编写很少或不用编写与事务相关的代码。因此，他们不依赖于Spring框架的事务API或任何其他事务API。



> **需要应用服务器来管理事务吗？**
> 
> 当企业级Java应用程序需要应用服务器时，Spring框架事务支持更改传统规则。
> 
> 特别是，不需要纯粹用于通过EJB进行声明式事务的应用程序服务器。实际上，即使应用程序服务器具有强大的JTA功能，也可能会决定，与EJB CMT相比，Spring框架的声明式事务提供了更强大和更搞笑的编程模型。
> 
> 通常，仅当应用程序需要处理跨多个资源的事务时，才需要应用程序服务器的JTA功能，而这并不是多数应用程序所必须的。许多高端应用程序使用单个高度可扩展的数据库（例如，Oracle RAC）来代替。独立事务管理（例如Atomikos Transactions和JOTM）是可选的。当然，可能需要其他应用程序服务器功能，例如Java Message Service(JMS)和Java EE Connector Architecture(JCA)。
> 
> Spring框架是用户可以选择合适将应用程序扩展到完全加载的应用程序服务器。不再使用EJB CMT或JTA的唯一选择是使用本地事务编写代码（例如JDBC连接上的事务），并且如果需要让代码在全局的容器管理的事务中运行，则面临大量的返工。使用Spring框架，仅需要更改配置文件中某些bean定义（而不是代码）。



## 1.2. 理解Spring框架的事务抽象

Spring事务抽象的关键是事务策略的概念。事务策略通过`TransactionManager`定义，特别是用于命令式事务管理的`org.springframework.transaction.PlatformTransactionManager`接口和用于反应式事务管理的`org.springframework.transaction.ReactiveTransactionManager`接口。下面列出了`PlatformTransactionManager`API：

```java
public interface PlatformTransactionManager extends TransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}
```

尽管可以从应用程序代码中以编程方式使用它，但它主要是一个SPI。因为`PlatformTransactionManager`是一个接口，因此根据需要可以轻松对其进行模拟或存根。它与注入JNDI之类的查找策略无关。`PlatformTransatcionManager`实现的定义与Spring框架IoC容器中的任何其他对象一样。 仅这一优点就使Spring框架事务成为一种有价值的抽象，即使在使用JTA时也是如此。与直接使用JTA相比，可以很容易地测试事务代码。



再次，根据Spring理念，`PlatformTransactionManager`接口的任何方法都可以抛出`TransactionException`，它是未检查异常（也就是说，它扩展了`java.lang.RuntimeExcepiton`类）。事务基础架构故障几乎是致命的。在极少数情况下，应用程序代码实际上可以从事务失败中恢复，应用程序开发人员仍然可以选择捕获并处理`TransactionException`。显著的一点是开发者不必被强制这么做。



方法`getTransaction(...)`返回一个`TransactionStatus`对象，依赖于`TransactionDefinition`参数。如果在当前调用栈中匹配的事务，那么返回的`TransactionStatus`可能代表一个新的事务或一个已存在的事务。后一种情况的含义是，与Java EE事务上下文一样，`TransactionStatus`与执行线程相关联。



Spring框架5.2以后，Spring为反应式应用程序提供了事务管理抽象，用在反应式类型或Kotlin。下面的例子展示了`org.springframework.transaction.ReactiveTransactionManager`中定义的事务策略：

```java
public interface ReactiveTransactionManager extends TransactionManager {

    Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;

    Mono<Void> commit(ReactiveTransaction status) throws TransactionException;

    Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;
}
```

尽管可以从应用程序代码中以编程方式使用它，但它主要是一个SPI。因为`ReactiveTransactionManager`是一个接口，因此根据需要可以轻松对其进行模拟或存根。



`TransactionDefinition`接口的定义：

* 传播性：通常，一个事务范围内的全部代码运行在这个事务中。但是，当事务上下文已经存在时，如果运行事务方法，就可以指定行为。例如，代码可以继续运行在一个已存在的事务中（通常的情况），或者已经存在的事务被挂起，并创建一个新的事务。Spring提供了与EJB CMT中相似的事务传播性选项。如需了解Spring中的事务传播性，请阅读`Transaction Propagation`。

* 隔离性：事务与其他事务工作隔离的程度。例如，一个事务可以看到另一个事务未提交的写入吗？

* 超时：在超时之前，事务要运行多久，并通过底层事务基础设施来自动回滚。

* 只读状态：当代码读取但不修改数据时，可以使用只读事务。只读事务在某些情况下可能是非常有用的优化，例如当使用Hibernate时。



这些设置反应了标准事务的概念。如果需要，可以参考那些讨论事务隔离级别或其他核心事务概念的资料。理解这些概念是使用Spring框架或其他任何事务管理解决方案的必要条件。



`TransactionStatus`接口为事务代码控制事务执行和查询事务状态提供了一个简单的方式。这些概念应该很熟悉，因为他们对于所有事务API都是通用的。下面展示了`TransactionStatus`接口：

```java
public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {

    @Override
    boolean isNewTransaction();

    boolean hasSavepoint();

    @Override
    void setRollbackOnly();

    @Override
    boolean isRollbackOnly();

    void flush();

    @Override
    boolean isCompleted();
}
```

无论在Spring中选择声明式还是编程式事务管理，定义正确的`TransactionManager`实现都是绝对必要的。通常，可以通过依赖注入来定义此实现。



`TransactionManager`实现通常需要了解其工作环境：JDBC，JTA，Hibernate等等。下面例子展示了如何定义一个本地`PlatformTransactionManager`实现（在这种情况下，使用纯JDBC）



可以通过创建一个bean来定义JDBC `DataSource`：

```xml
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${jdbc.driverClassName}" />
    <property name="url" value="${jdbc.url}" />
    <property name="username" value="${jdbc.username}" />
    <property name="password" value="${jdbc.password}" />
</bean>
```

相关的`PlatformTransactionManager`bean 定义然后引用`DataSource`定义。它应该类似于下面的例子：

```xml
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

如果在Java EE容器中使用JTA，可以通过JNDI获得的容器`DataSource`以及Spring的`JtaTransactionManager`。下面的例子展示了JTA和JNDI查找version：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee
        https://www.springframework.org/schema/jee/spring-jee.xsd">

    <jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/>

    <bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />

    <!-- other <bean/> definitions here -->

</beans>
```

`JtaTransactionManager`不需要了解`DataSource`（或任何指定资源），因为它使用容器的全局事务管理基础设施。



> 前面使用了`jee`命名空间中的`<jndi-lookup/>`标签来定义`dataSource`bean。更多信息可以参考`The JEE Schema`。



> 如果使用JTA，则无论使用哪种数据访问技术（无论是JDBC，Hibernate JPA或其他任何支持的技术），事务管理器定义都应该看起来相同。这是由于JTA事务是全局事务，它可以征用任何事务资源。



在所有Spring事务设置中，无需更改应用程序代码。可以仅通过更改配置来更改事务的管理方式，即使意味着从本地事务转移到全局事务。



### 1.2.1. Hibernate事务设置

可以想接下来展示的例子一样，简单地使用Hibernate本地事务。在这种情况下，需要定义一个`LocalSessionFactoryBean`，应用程序代码可以使用包含Hibernate `Session`的实例。



`DataSource`的bean定义与本地JDBC例子相同，因此，不会在下面的例子中展示。

> 如果`DataSrouce`（通过任何非JTA事务管理其来使用）是通过JNDI来查找并通过Java EE容器来管理，它应该是非事务的，因为Spring框架来管理事务（而不是Java EE容器）。



`txManager` bean在这个例子中是`HibernateTransactionManager`类型。与`DataSourceTransactionManager`需要引用`DataSource`类似，`HibernateTransactionManager`需要引用`SessionFactory`。下面的例子声明了`sessionFactory`和`txManager`bean：

```xml
<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mappingResources">
        <list>
            <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
        </list>
    </property>
    <property name="hibernateProperties">
        <value>
            hibernate.dialect=${hibernate.dialect}
        </value>
    </property>
</bean>

<bean id="txManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
    <property name="sessionFactory" ref="sessionFactory"/>
</bean>
```



如果使用Hibernate和Java EE容器管理的JTA事务，则应使用与前面JDBC JTA实例相同的`JtaTransactionManager`，如下所示：

```xml
<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mappingResources">
        <list>
            <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
        </list>
    </property>
    <property name="hibernateProperties">
        <value>
            hibernate.dialect=${hibernate.dialect}
            hibernate.transaction.coordinator_class=jta
            hibernate.connection.handling_mode=DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT
        </value>
    </property>
</bean>

<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
```



或者，可以将`JtaTransactionManager`传递给`LocalSessionFactionBean`：

```xml
<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mappingResources">
        <list>
            <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
        </list>
    </property>
    <property name="hibernateProperties">
        <value>
            hibernate.dialect=${hibernate.dialect}
        </value>
    </property>
    <property name="jtaTransactionManager" ref="txManager"/>
</bean>

<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
```



## 1.3. 使用事务同步资源

现在应该清除了如何建立不同的事务管理器和他们是怎样链接到需要同步到事务的相关资源的（例如，`DataSourceTransactionManager`到JDBC `DataSource`,`HibernateTransactionManager`到Hibernate `SessionFactory`等等）。本节描述了应用程序代码如何保证这些资源的创建、重用、和即使清理（直接或间接的通过使用持久化API，例如JDBC，Hibernate，或JPA）。本节也讨论了通过相关的`TransactionManager`如何触发事务同步。



### 1.3.1. 高级别同步方法

首选方法是使用Spring的基于模板的高层持久性集成APIs，或将本地ORM APIs与具有事务感知功能的工厂bean或代理一起使用，以遍历本地资源工厂。 这些感知事务的解决方案在内部处理资源的创建和重用、清理、可选的资源事务同步以及异常映射。一次，用户数据访问代码不必解决这些任务，而完全可以专注非样板的持久性逻辑。通常，可以使用本地ORM API或`JdbcTemplate`进行JDBC访问。这些解决方案将在本参考文档后续部分详细介绍。



### 1.3.2. 低级别同步方法

例如`DataSourceUtils`（对于JDBC），`EntityManagerFactoryUtils`（对于JPA），`SessionFactoryUtils`（对于Hibernate）等等这些类都是低级别的。当想让应用程序代码直接处理原生资源类型的持久性API,使用这些类来确保适当的Spring Framework-managed实例,事务是(可选)同步的,在这个过程中发生的和异常正确映射到一个一致的API。



例如，对于JDBC,为了代替传统的在`DataSource`上调用`getConnection()`的JDBC方法，可以使用Spring的`org.springframework.jdbc.datasource.DataSourceUtils`类：

```java
Connection conn = DataSourceUtils.getConnection(dataSource);
```

如果现有事务已经有与其同步的连接，会返回这个实例。否则，方法调用会触发创建新连接，该连接（可选）同步到现有任何事务，并可拱该统一事务中的后续重用。如前所述，任何`SQLException`都包装在Spring框架的`CannotGetJdbcConnectionException`中，该框架是未经检查的`DataAccessException`类型的层次结构之一。与从`SQLException`可以容易获得的信息相比，这种方法提供的信息更多，并确保了跨数据库甚至跨不同持久性技术的可移植性。



这种方法在没有Spring的事务管理器的情况下也可以使用（事务同步是可选的），因此无论是否使用Spring进行事务管理，都可以使用它。



 当然，一旦使用了Spring的JDBC支持、JPA支持或Hibernate支持，通常不喜欢使用DataSourceUtils或其他助手类，因为更喜欢使用Spring抽象而不是直接使用相关api。例如，如果使用Spring的`JdbcTemplate`或`jdbc.object`包来简化JDBC的使用，则正确的链接获取将在后台进行，并且无需编写任何特殊代码。



### 1.3.3. `TransactionAwareDataSourceProxy`

一个更低级别的是`TransactionAwareDataSourceProxy`类。它是目标`DataSource`的代理，用来包装目标`DataSource`以添加对spring管理的事务的感知。在这方面，它类似于由Java EE服务器提供的事务性JNDI数据源。



应该几乎不需要使用这个类，除非已经存在的代码必须调用或传递一个标准JDBC `DataSource`接口实现。在这种情况下，该代码可能是有用的，但参与了Spring管理的事务。可以使用前面提到的高级抽象来编写新代码。



## 1.4. 声明式事务管理

> 多数Spring框架用户使用声明式事务管理。该选项对应用程序代码有最低影响，因此，与无创轻量级容器的理念最一致。



Spring框架的声明式事务使用的是Spring面向切面编程(AOP)。但是，由于事务切面的代码随Spring框架发行版一起提供，并且可以以样板方式使用，因此通常不必理解AOP概念即可有效使用此代码。



Spring框架的声明式事务管理与EJB CMT类似，可以指定单个方法级别的事务行为。如果需要，可以通过事务上下文调用`setRollbackOnly()`。两种类型的事务管理之间的区别是：

* 与绑定JTA的EJB CMT不同，Spring框架的声明式事务可以用在任何环境。它可以与JTA事务，通过使用JDBC的本地事务，JPA或Hibernate一起工作。

* 可以将Spring框架声明式事务管理应用于任何类，而不仅限于EJB之类的特殊类。

* Spring框架提供声明式的回滚机制，EJB没有相同的功能。提供了编程时和声明式两种回滚机制。

* Spring框架可以通过AOP自定义事务行为。例如，可以在事务回滚情况下插入自定义行为。也可以伴随事务通知增加任意通知。使用EJB CMT，不能影响容器的事务管理，除非使用`setRollbackOnly()`。

* Spring框架不支持跨远程调用的事务上下文传播。如果需要这个功能，建议使用EJB。但是，在使用这样的功能之前应仔细考虑，因为，通常情况下，不希望事务跨远程调用。



回滚规则的概念是重要的。他们可以指定在哪些异常情况下应该使用自动回滚。可以在配置中声明它，不需要使用Java代码。因此，尽管可以仍然在`TransactionStatus`对象上调用`setRollbackOnly()`来回滚当前事务，但大多数情况下，可以指定一个规则，即`MyApplicationException`必须始终导致回滚。此选项的主要优点是业务对象不依赖于事务基础设施。例如，他们通常不需要导入Spring事务API或其他SpringAPI。



尽管EJB容器默认行为会在系统异常（通常是运行时异常）时自动回滚，但EJB CMT不会在应用程序异常（即`java.rim.RemoteException`以外的检查异常）时自动回滚。尽管Spring声明式事务管理的默认行为遵循EJB约定（仅针对未检查的异常自动回滚），但自定义此行为通常很有用。



### 1.4.1. 理解Spirng框架的声明式事务实现

仅仅告诉使用`@Transactional`对类进行注解，将`@EnableTransactionManagement`添加到配置中，并希望了解其全部工作原理是不够的。为了提供更深入的理解，本节解释了Spring框架声明式事务基础设施在事务相关问题上下文中的内部工作。



关于Spring框架的声明式事务支持，最重要的概念是通过AOP代理启用此支持，并且事务通知由元数据驱动（当前基于XML或基于注解）。AOP与事务元数据的组合产生了一个AOP代理，该代理将`TransactionInterceptor`与适当的`TransactionManager`实现结合使用，以驱动方法调用周围的事务。



Spring框架的`TransactionInterceptor`为命令式和反应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。



事务管理风格影响需要哪个事务管理器。命令式事务需要`PlatformTransactionManager`，而反应式事务使用`ReactiveTransactionManager`实现。

> `@Transactional`通常与有`PlatformTransactionManager`管理的线程绑定事务一起使用，将事务暴露给当前执行线程内的所有数据访问操作。注意，这不会传播到方法中新启动的线程。



下图展示了在事务代理上调用方法的概念视图：

![tx](https://docs.spring.io/spring-framework/docs/current/reference/html/images/tx.png)
