# 1. 事务管理

Spring框架为事务管理提供了一致性的抽象，具有以下优点：

* 跨不同事务API的一致性编程模型，例如Java Transaction API(JTA)，JDBC，Hibernate，Java Persistence API(JPA)。

* 提供声明式事务管理。

* 为编程事务管理提供比复杂事务管理API（例如JTA）更简单的API。

* 与Spring的数据访问抽象的出色集成。



以下部分描述了Spring框架的事务特性和技术：

* Spring框架事务支持模型的优点：描述了为什么可以使用Spring框架事务抽象来代替EJB容器管理事务或选择通过专用API驱动本地事务 ，例如Hibernate。

* 理解Spring框架的事务抽象：列出核心类，并描述如何配置并从多种源中获取`DataSource`实例。

* 将资源与事务同步：描述了应用程序代码如何确保正确创建、重用和清理资源。

* 声明式事务管理：描述了对声明式事务的支持。

* 编程事务管理：涵盖可编程的支持。

* 事务绑定事件：描述了如何在事务中使用应用程序事件。



## 1.1. Spring框架事务支持模型的优点

传统上，Java EE开发者对于事务管理来说有两个选择：全局或本地事务，两者都有很大的局限性。下节将回顾全局和本地事务管理类，随后讨论Spring框架事务管理如何解决全局和本地事务模型的局限性。



### 1.1.1. 全局事务

全局事务可以让用户使用多种事务资源，通常是关系型数据库和消息队列。应用程序服务通过JTA管理全局事务，它很繁琐（部分是由于异常模型）。此外，JTA `UserTransaction`通常来源于JNDI，这意味着还需要使用JNDI才能使用JTA。全局事务的使用限制了任何应用程序代码的潜在的重用能力，因为JTA通常仅在应用程序服务环境中可用。



以前，使用全局事务的首选方法是通过EJB CMT(Container Managed Transaction)。CMT是声明式事务管理的一种形式（与程序性事务管理不同）。EJB CMT移除了与事务相关的JNDI查找需要，尽管使用EJB本身需要JNDI。它消除了大多数但不是全部的通过Java代码来控制事务的需要。一个重要的缺点是，CMT与JTA和应用程序服务器环境相关联。此外，如果选择使用EJBs实现业务逻辑，它是唯一可用的。通常，EJB的缺点很大，以至于这不是一个有吸引力的提议，特别是面对声明式事务管理的强制选择时。



### 1.1.2. 本地事务

本地事务是特殊的资源，例如与JDBC相关连的事务。本地事务可能使用更简单，但是有一个重要的缺点：他们不能在跨多个事务资源上工作。例如，使用JDBC连接管理的事务代码不能在全局JTA事务中运行。因为应用服务器不参与事务管理，它不能确保多个资源之间的正确性。（值得注意的是，大多数应用程序使用单个事务资源。）另一个缺点是本地事务对编程模型具有侵入性。



### 1.1.3. Spring框架的一致性事务模型

Spring解决了全局和本地事务的缺点。它让开发者能在任何环境中使用一致的编程模型。只需要写一次代码，就可以从不同环境中的不同事务策略中受益。Spring提供声明和编程事务管理。多数用户更喜欢声明式事务管理，这也是在多数情况下建议使用的。



通过编程事务管理，开发人员可以使用Spring框架事务抽象，该抽象可以在任何基于事务基础框架下正常工作。使用首选的声明式事务模型，开发人员通常只编写很少或不用编写与事务相关的代码。因此，他们不依赖于Spring框架的事务API或任何其他事务API。



> **需要应用服务器来管理事务吗？**
> 
> 当企业级Java应用程序需要应用服务器时，Spring框架事务支持更改传统规则。
> 
> 特别是，不需要纯粹用于通过EJB进行声明式事务的应用程序服务器。实际上，即使应用程序服务器具有强大的JTA功能，也可能会决定，与EJB CMT相比，Spring框架的声明式事务提供了更强大和更搞笑的编程模型。
> 
> 通常，仅当应用程序需要处理跨多个资源的事务时，才需要应用程序服务器的JTA功能，而这并不是多数应用程序所必须的。许多高端应用程序使用单个高度可扩展的数据库（例如，Oracle RAC）来代替。独立事务管理（例如Atomikos Transactions和JOTM）是可选的。当然，可能需要其他应用程序服务器功能，例如Java Message Service(JMS)和Java EE Connector Architecture(JCA)。
> 
> Spring框架是用户可以选择合适将应用程序扩展到完全加载的应用程序服务器。不再使用EJB CMT或JTA的唯一选择是使用本地事务编写代码（例如JDBC连接上的事务），并且如果需要让代码在全局的容器管理的事务中运行，则面临大量的返工。使用Spring框架，仅需要更改配置文件中某些bean定义（而不是代码）。



## 1.2. 理解Spring框架的事务抽象

Spring事务抽象的关键是事务策略的概念。事务策略通过`TransactionManager`定义，特别是用于命令式事务管理的`org.springframework.transaction.PlatformTransactionManager`接口和用于反应式事务管理的`org.springframework.transaction.ReactiveTransactionManager`接口。下面列出了`PlatformTransactionManager`API：

```java
public interface PlatformTransactionManager extends TransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}
```

尽管可以从应用程序代码中以编程方式使用它，但它主要是一个SPI。因为`PlatformTransactionManager`是一个接口，因此根据需要可以轻松对其进行模拟或存根。它与注入JNDI之类的查找策略无关。`PlatformTransatcionManager`实现的定义与Spring框架IoC容器中的任何其他对象一样。 仅这一优点就使Spring框架事务成为一种有价值的抽象，即使在使用JTA时也是如此。与直接使用JTA相比，可以很容易地测试事务代码。



再次，根据Spring理念，`PlatformTransactionManager`接口的任何方法都可以抛出`TransactionException`，它是未检查异常（也就是说，它扩展了`java.lang.RuntimeExcepiton`类）。事务基础架构故障几乎是致命的。在极少数情况下，应用程序代码实际上可以从事务失败中恢复，应用程序开发人员仍然可以选择捕获并处理`TransactionException`。显著的一点是开发者不必被强制这么做。



方法`getTransaction(...)`返回一个`TransactionStatus`对象，依赖于`TransactionDefinition`参数。如果在当前调用栈中匹配的事务，那么返回的`TransactionStatus`可能代表一个新的事务或一个已存在的事务。后一种情况的含义是，与Java EE事务上下文一样，`TransactionStatus`与执行线程相关联。



Spring框架5.2以后，Spring为反应式应用程序提供了事务管理抽象，用在反应式类型或Kotlin。下面的例子展示了`org.springframework.transaction.ReactiveTransactionManager`中定义的事务策略：

```java
public interface ReactiveTransactionManager extends TransactionManager {

    Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;

    Mono<Void> commit(ReactiveTransaction status) throws TransactionException;

    Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;
}
```

尽管可以从应用程序代码中以编程方式使用它，但它主要是一个SPI。因为`ReactiveTransactionManager`是一个接口，因此根据需要可以轻松对其进行模拟或存根。



`TransactionDefinition`接口的定义：

* 传播性：通常，一个事务范围内的全部代码运行在这个事务中。但是，当事务上下文已经存在时，如果运行事务方法，就可以指定行为。例如，代码可以继续运行在一个已存在的事务中（通常的情况），或者已经存在的事务被挂起，并创建一个新的事务。Spring提供了与EJB CMT中相似的事务传播性选项。如需了解Spring中的事务传播性，请阅读`Transaction Propagation`。

* 隔离性：事务与其他事务工作隔离的程度。例如，一个事务可以看到另一个事务未提交的写入吗？

* 超时：在超时之前，事务要运行多久，并通过底层事务基础设施来自动回滚。

* 只读状态：当代码读取但不修改数据时，可以使用只读事务。只读事务在某些情况下可能是非常有用的优化，例如当使用Hibernate时。



这些设置反应了标准事务的概念。如果需要，可以参考那些讨论事务隔离级别或其他核心事务概念的资料。理解这些概念是使用Spring框架或其他任何事务管理解决方案的必要条件。



`TransactionStatus`接口为事务代码控制事务执行和查询事务状态提供了一个简单的方式。这些概念应该很熟悉，因为他们对于所有事务API都是通用的。下面展示了`TransactionStatus`接口：

```java
public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {

    @Override
    boolean isNewTransaction();

    boolean hasSavepoint();

    @Override
    void setRollbackOnly();

    @Override
    boolean isRollbackOnly();

    void flush();

    @Override
    boolean isCompleted();
}
```

无论在Spring中选择声明式还是编程式事务管理，定义正确的`TransactionManager`实现都是绝对必要的。通常，可以通过依赖注入来定义此实现。



`TransactionManager`实现通常需要了解其工作环境：JDBC，JTA，Hibernate等等。下面例子展示了如何定义一个本地`PlatformTransactionManager`实现（在这种情况下，使用纯JDBC）



可以通过创建一个bean来定义JDBC `DataSource`：

```xml
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${jdbc.driverClassName}" />
    <property name="url" value="${jdbc.url}" />
    <property name="username" value="${jdbc.username}" />
    <property name="password" value="${jdbc.password}" />
</bean>
```

相关的`PlatformTransactionManager`bean 定义然后引用`DataSource`定义。它应该类似于下面的例子：

```xml
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

如果在Java EE容器中使用JTA，可以通过JNDI获得的容器`DataSource`以及Spring的`JtaTransactionManager`。下面的例子展示了JTA和JNDI查找version：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee
        https://www.springframework.org/schema/jee/spring-jee.xsd">

    <jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/>

    <bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />

    <!-- other <bean/> definitions here -->

</beans>
```

`JtaTransactionManager`不需要了解`DataSource`（或任何指定资源），因为它使用容器的全局事务管理基础设施。



> 前面使用了`jee`命名空间中的`<jndi-lookup/>`标签来定义`dataSource`bean。更多信息可以参考`The JEE Schema`。



> 如果使用JTA，则无论使用哪种数据访问技术（无论是JDBC，Hibernate JPA或其他任何支持的技术），事务管理器定义都应该看起来相同。这是由于JTA事务是全局事务，它可以征用任何事务资源。



在所有Spring事务设置中，无需更改应用程序代码。可以仅通过更改配置来更改事务的管理方式，即使意味着从本地事务转移到全局事务。



### 1.2.1. Hibernate事务设置

可以想接下来展示的例子一样，简单地使用Hibernate本地事务。在这种情况下，需要定义一个`LocalSessionFactoryBean`，应用程序代码可以使用包含Hibernate `Session`的实例。



`DataSource`的bean定义与本地JDBC例子相同，因此，不会在下面的例子中展示。

> 如果`DataSrouce`（通过任何非JTA事务管理其来使用）是通过JNDI来查找并通过Java EE容器来管理，它应该是非事务的，因为Spring框架来管理事务（而不是Java EE容器）。



`txManager` bean在这个例子中是`HibernateTransactionManager`类型。与`DataSourceTransactionManager`需要引用`DataSource`类似，`HibernateTransactionManager`需要引用`SessionFactory`。下面的例子声明了`sessionFactory`和`txManager`bean：

```xml
<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mappingResources">
        <list>
            <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
        </list>
    </property>
    <property name="hibernateProperties">
        <value>
            hibernate.dialect=${hibernate.dialect}
        </value>
    </property>
</bean>

<bean id="txManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
    <property name="sessionFactory" ref="sessionFactory"/>
</bean>
```



如果使用Hibernate和Java EE容器管理的JTA事务，则应使用与前面JDBC JTA实例相同的`JtaTransactionManager`，如下所示：

```xml
<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mappingResources">
        <list>
            <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
        </list>
    </property>
    <property name="hibernateProperties">
        <value>
            hibernate.dialect=${hibernate.dialect}
            hibernate.transaction.coordinator_class=jta
            hibernate.connection.handling_mode=DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT
        </value>
    </property>
</bean>

<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
```



或者，可以将`JtaTransactionManager`传递给`LocalSessionFactionBean`：

```xml
<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mappingResources">
        <list>
            <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
        </list>
    </property>
    <property name="hibernateProperties">
        <value>
            hibernate.dialect=${hibernate.dialect}
        </value>
    </property>
    <property name="jtaTransactionManager" ref="txManager"/>
</bean>

<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
```



## 1.3. 使用事务同步资源

现在应该清除了如何建立不同的事务管理器和他们是怎样链接到需要同步到事务的相关资源的（例如，`DataSourceTransactionManager`到JDBC `DataSource`,`HibernateTransactionManager`到Hibernate `SessionFactory`等等）。本节描述了应用程序代码如何保证这些资源的创建、重用、和即使清理（直接或间接的通过使用持久化API，例如JDBC，Hibernate，或JPA）。本节也讨论了通过相关的`TransactionManager`如何触发事务同步。



### 1.3.1. 高级别同步方法

首选方法是使用Spring的基于模板的高层持久性集成APIs，或将本地ORM APIs与具有事务感知功能的工厂bean或代理一起使用，以遍历本地资源工厂。 这些感知事务的解决方案在内部处理资源的创建和重用、清理、可选的资源事务同步以及异常映射。一次，用户数据访问代码不必解决这些任务，而完全可以专注非样板的持久性逻辑。通常，可以使用本地ORM API或`JdbcTemplate`进行JDBC访问。这些解决方案将在本参考文档后续部分详细介绍。



### 1.3.2. 低级别同步方法

例如`DataSourceUtils`（对于JDBC），`EntityManagerFactoryUtils`（对于JPA），`SessionFactoryUtils`（对于Hibernate）等等这些类都是低级别的。当想让应用程序代码直接处理原生资源类型的持久性API,使用这些类来确保适当的Spring Framework-managed实例,事务是(可选)同步的,在这个过程中发生的和异常正确映射到一个一致的API。



例如，对于JDBC,为了代替传统的在`DataSource`上调用`getConnection()`的JDBC方法，可以使用Spring的`org.springframework.jdbc.datasource.DataSourceUtils`类：

```java
Connection conn = DataSourceUtils.getConnection(dataSource);
```

如果现有事务已经有与其同步的连接，会返回这个实例。否则，方法调用会触发创建新连接，该连接（可选）同步到现有任何事务，并可拱该统一事务中的后续重用。如前所述，任何`SQLException`都包装在Spring框架的`CannotGetJdbcConnectionException`中，该框架是未经检查的`DataAccessException`类型的层次结构之一。与从`SQLException`可以容易获得的信息相比，这种方法提供的信息更多，并确保了跨数据库甚至跨不同持久性技术的可移植性。



这种方法在没有Spring的事务管理器的情况下也可以使用（事务同步是可选的），因此无论是否使用Spring进行事务管理，都可以使用它。



 当然，一旦使用了Spring的JDBC支持、JPA支持或Hibernate支持，通常不喜欢使用DataSourceUtils或其他助手类，因为更喜欢使用Spring抽象而不是直接使用相关api。例如，如果使用Spring的`JdbcTemplate`或`jdbc.object`包来简化JDBC的使用，则正确的链接获取将在后台进行，并且无需编写任何特殊代码。



### 1.3.3. `TransactionAwareDataSourceProxy`

一个更低级别的是`TransactionAwareDataSourceProxy`类。它是目标`DataSource`的代理，用来包装目标`DataSource`以添加对spring管理的事务的感知。在这方面，它类似于由Java EE服务器提供的事务性JNDI数据源。



应该几乎不需要使用这个类，除非已经存在的代码必须调用或传递一个标准JDBC `DataSource`接口实现。在这种情况下，该代码可能是有用的，但参与了Spring管理的事务。可以使用前面提到的高级抽象来编写新代码。



## 1.4. 声明式事务管理

> 多数Spring框架用户使用声明式事务管理。该选项对应用程序代码有最低影响，因此，与无创轻量级容器的理念最一致。



Spring框架的声明式事务使用的是Spring面向切面编程(AOP)。但是，由于事务切面的代码随Spring框架发行版一起提供，并且可以以样板方式使用，因此通常不必理解AOP概念即可有效使用此代码。



Spring框架的声明式事务管理与EJB CMT类似，可以指定单个方法级别的事务行为。如果需要，可以通过事务上下文调用`setRollbackOnly()`。两种类型的事务管理之间的区别是：

* 与绑定JTA的EJB CMT不同，Spring框架的声明式事务可以用在任何环境。它可以与JTA事务，通过使用JDBC的本地事务，JPA或Hibernate一起工作。

* 可以将Spring框架声明式事务管理应用于任何类，而不仅限于EJB之类的特殊类。

* Spring框架提供声明式的回滚机制，EJB没有相同的功能。提供了编程时和声明式两种回滚机制。

* Spring框架可以通过AOP自定义事务行为。例如，可以在事务回滚情况下插入自定义行为。也可以伴随事务通知增加任意通知。使用EJB CMT，不能影响容器的事务管理，除非使用`setRollbackOnly()`。

* Spring框架不支持跨远程调用的事务上下文传播。如果需要这个功能，建议使用EJB。但是，在使用这样的功能之前应仔细考虑，因为，通常情况下，不希望事务跨远程调用。



回滚规则的概念是重要的。他们可以指定在哪些异常情况下应该使用自动回滚。可以在配置中声明它，不需要使用Java代码。因此，尽管可以仍然在`TransactionStatus`对象上调用`setRollbackOnly()`来回滚当前事务，但大多数情况下，可以指定一个规则，即`MyApplicationException`必须始终导致回滚。此选项的主要优点是业务对象不依赖于事务基础设施。例如，他们通常不需要导入Spring事务API或其他SpringAPI。



尽管EJB容器默认行为会在系统异常（通常是运行时异常）时自动回滚，但EJB CMT不会在应用程序异常（即`java.rim.RemoteException`以外的检查异常）时自动回滚。尽管Spring声明式事务管理的默认行为遵循EJB约定（仅针对未检查的异常自动回滚），但自定义此行为通常很有用。



### 1.4.1. 理解Spirng框架的声明式事务实现

仅仅告诉使用`@Transactional`对类进行注解，将`@EnableTransactionManagement`添加到配置中，并希望了解其全部工作原理是不够的。为了提供更深入的理解，本节解释了Spring框架声明式事务基础设施在事务相关问题上下文中的内部工作。



关于Spring框架的声明式事务支持，最重要的概念是通过AOP代理启用此支持，并且事务通知由元数据驱动（当前基于XML或基于注解）。AOP与事务元数据的组合产生了一个AOP代理，该代理将`TransactionInterceptor`与适当的`TransactionManager`实现结合使用，以驱动方法调用周围的事务。



Spring框架的`TransactionInterceptor`为命令式和反应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。



事务管理风格影响需要哪个事务管理器。命令式事务需要`PlatformTransactionManager`，而反应式事务使用`ReactiveTransactionManager`实现。

> `@Transactional`通常与有`PlatformTransactionManager`管理的线程绑定事务一起使用，将事务暴露给当前执行线程内的所有数据访问操作。注意，这不会传播到方法中新启动的线程。



下图展示了在事务代理上调用方法的概念视图：

![tx](https://docs.spring.io/spring-framework/docs/current/reference/html/images/tx.png)



### 1.4.2. 声明式事务实现的例子

思考下面的接口和附带的实现。这个例子使用`Foo`和`Bar`类作为占位符，以便可以专注于事务使用而不关注特定类型的领域模型。就本示例而言，`DefaultFooService`类在每个已实现方法的主题中抛出`UnsupportedOperationException`实例的事实是很好的。该行为让用户可以查看正在创建的事务并且响应`UnsupportedOperationException`实例然后回滚。下面展示了`FooService`接口：

```java
// the service interface that we want to make transactional

package x.y.service;

public interface FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    void insertFoo(Foo foo);

    void updateFoo(Foo foo);

}
```

下面的例子是前面接口的实现：

```java
package x.y.service;

public class DefaultFooService implements FooService {

    @Override
    public Foo getFoo(String fooName) {
        // ...
    }

    @Override
    public Foo getFoo(String fooName, String barName) {
        // ...
    }

    @Override
    public void insertFoo(Foo foo) {
        // ...
    }

    @Override
    public void updateFoo(Foo foo) {
        // ...
    }
}
```

假设`FooService`的前两个方法`getFoo(String)`和`getFoo(String fooName,String barName)`必须在有只读语义的事务上下文中运行，其他两个方法`insertFoo(String)`和`updateFoo(String)`必须在只写语义的事务上下文中运行。以下几节将详细说明以下配置：

```xml
<!-- from the file 'context.xml' -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- this is the service object that we want to make transactional -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- the transactional advice (what 'happens'; see the <aop:advisor/> bean below) -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <!-- the transactional semantics... -->
        <tx:attributes>
            <!-- all methods starting with 'get' are read-only -->
            <tx:method name="get*" read-only="true"/>
            <!-- other methods use the default transaction settings (see below) -->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!-- ensure that the above transactional advice runs for any execution
        of an operation defined by the FooService interface -->
    <aop:config>
        <aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>
    </aop:config>

    <!-- don't forget the DataSource -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
        <property name="username" value="scott"/>
        <property name="password" value="tiger"/>
    </bean>

    <!-- similarly, don't forget the TransactionManager -->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- other <bean/> definitions here -->

</beans>
```

检查之前的配置。它假设服务对象`fooService`具有事务性。事务的语义被封装在`<tx:advice/>`定义中。`<tx:advice/>`定义读取所有”以`get`开头的方法“在只读事务上下文中运行，并且其他方法使用默认的事务语义运行”。`<tx:advice/>`标签的`transaction-manager`属性设置为`TransactionManager` bean的名称。



`<aop:config/>`定义保证通过`txAdvice` bean定义的事务通知在程序中可以运行在适当的切点。首先，定义了一个在`FooService`接口匹配任何方法执行的切点（`fooServiceOperation`）。然后，使用advisor连接通知和切点。结果表明，通过`txAdvice`定义的通知可以在`fooServiceOperation`中的执行上运行。



`<aop:pointcut/>`元素中的表达式是AspectJ切点表达式。



一个普遍的需求是使整个服务层具有事务性。最佳的方式是改变切点表达式来匹配服务层中的任何操作。下面的例子展示了如何执行此操作：

```xml
<aop:config>
    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
</aop:config>
```



注意，现在已经分析了配置，你可能会问，所有的这些配置实际做了什么？



前面展示的配置用来创建一个事务性的代理环绕在从`fooService`bean定义中创建的对象。代理是通过事务行的通知配置的，当在代理上调用适当的方法时，事务会被启动，挂起，标记为只读等等，这依赖于连接方法的事务配置。思考下面的程序：

```java
public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class);
        FooService fooService = (FooService) ctx.getBean("fooService");
        fooService.insertFoo (new Foo());
    }
}
```

运行上述程序的输出应该类似于以下内容(为清楚起见，由DefaultFooService类的insertFoo(..)方法抛出的UnsupportedOperationException的Log4J输出和堆栈跟踪已被截断)。



### 1.4.3. 回滚事务声明

前面的例子列出了如何为类指定事务设置的基础，通常声明在应用程序中的服务层类。本节将描述如何以一种简单的方式来控制事务的回滚。



 向Spring框架的事务基础设施指示要回滚事务工作的推荐方法是从当前在事务上下文中执行的代码中抛出Exception异常。Spring框架的事务基础设施代码捕获了任何未处理的`Exception`，因为它将调用堆栈冒泡，并决定是否将事务标记为回滚。



在默认的配置中，Spring框架的事务基础设施代码仅在运行时未检查的异常情况下才标记回滚事务。也就是说，当抛出的异常是`RuntimeException`实例或其子类时。（`Error`实例也会默认导致回滚）。已检查的异常从事务抛出在默认配置中不会导致回滚。



可以为回滚配置合适的异常类型，包括已检查异常。下面的XML片段展示了如何配置一个已检查的，特定于应用程序的异常类型配置回滚：

```xml
<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
    <tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>
    <tx:method name="*"/>
    </tx:attributes>
</tx:advice>
```



如果不想在异常抛出时，事务回滚，可以指定`no rollback rules`。下面的例子告诉Spring框架事务基础设施即使面对未处理的`InstrumentNotFoundException`，也要提交伴随的事务：

```xml
<tx:advice id="txAdvice">
    <tx:attributes>
    <tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>
    <tx:method name="*"/>
    </tx:attributes>
</tx:advice>
```

当Spring框架事务基础设施捕获异常并且资讯已配置的回滚规则以确定是否将事务标记为回滚时，最强的匹配规则获胜。因此，在下面配置的情况下，出`InstrumentNotFoundException`之外的任何异常都会导致事务回滚：

```xml
<tx:advice id="txAdvice">
    <tx:attributes>
    <tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>
    </tx:attributes>
</tx:advice>
```



也可以通过编程方式表示需要的回滚。虽然简单，但它非常具有侵入性，并且将代码紧密地耦合到Spring框架的事务基础设施中。下面的例子展示了如何以编程方式表示一个需要的回滚：

```java
public void resolvePosition() {
    try {
        // some business logic...
    } catch (NoProductInStockException ex) {
        // trigger rollback programmatically
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}
```

强烈鼓励尽可能使用声明式事务回滚。如果您绝对需要它，则可以使用程序化回滚，但是面对一个干净的基于POJO的体系结构，它的用法就不那么理想了。



### 1.4.4. 为不同的beans配置不同的事务语义

思考一下这种情景，当有大量的服务层对象时，想要为每个服务层对象配置不同的事务。可以通过定义不同的带有不同`pointcut`和`advice-ref`属性值的`<aop:advisor>`。



最为对比，首先假设所有的服务层类定义在`x.y.service`包中。要是所有在该包（或子包）中定义的类实例切名称以`Service`结尾的bean具有默认的事务配置，可以编写一下内容：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <aop:config>

        <aop:pointcut id="serviceOperation"
                expression="execution(* x.y.service..*Service.*(..))"/>

        <aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>

    </aop:config>

    <!-- these two beans will be transactional... -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>
    <bean id="barService" class="x.y.service.extras.SimpleBarService"/>

    <!-- ... and these two beans won't -->
    <bean id="anotherService" class="org.xyz.SomeService"/> <!-- (not in the right package) -->
    <bean id="barManager" class="x.y.service.SimpleBarManager"/> <!-- (doesn't end in 'Service') -->

    <tx:advice id="txAdvice">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!-- other transaction infrastructure beans such as a TransactionManager omitted... -->

</beans>
```

下面的例子说明如何使用完全不同的事务设置配置两个不同的bean:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <aop:config>

        <aop:pointcut id="defaultServiceOperation"
                expression="execution(* x.y.service.*Service.*(..))"/>

        <aop:pointcut id="noTxServiceOperation"
                expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>

        <aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>

        <aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>

    </aop:config>

    <!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- this bean will also be transactional, but with totally different transactional settings -->
    <bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/>

    <tx:advice id="defaultTxAdvice">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <tx:advice id="noTxAdvice">
        <tx:attributes>
            <tx:method name="*" propagation="NEVER"/>
        </tx:attributes>
    </tx:advice>

    <!-- other transaction infrastructure beans such as a TransactionManager omitted... -->

</beans>
```

### 1.4.5. `<tx:advice>`设置

本节总结了多种事务设置以便可以通过使用`<tx:advice/>`标签指定。默认的`<tx:advice/>`设置是：

* 传播性设置是`REQUIRED`。

* 隔离级别是`DEFAULT`。

* 事务是读写。

* 事务超时默认为基础事务系统的默认超时，如果不支持超时，则默认为无。

* 任何`RuntimeException`触发回滚，任何已检查异常不会。



可以改变这些默认设置。下面的表格总结了各种`<tx:method>`标签的属性，他们嵌套在`<tx:advice/>`和`<tx:attributes/>`标签中：

| Attribute       | Required? | Default  | Description                                                                                                                                                                                                                                         |
| --------------- | --------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name            | yes       |          | Method names with which the transaction attributes are to be associated. The wildcard (*) character can be used to associate the same transaction attribute settings with a number of methods (for example, get*, handle*, on*Event, and so forth). |
| propagation     | no        | REQUIRED | Transaction propagation behavior.                                                                                                                                                                                                                   |
| isolation       | no        | DEFAULT  | Transaction isolation level. Only applicable to propagation settings of REQUIRED or REQUIRES_NEW.                                                                                                                                                   |
| timeout         | no        | -1       | Transaction timeout (seconds). Only applicable to propagation REQUIRED or REQUIRES_NEW.                                                                                                                                                             |
| read-only       | no        | false    | Read-write versus read-only transaction. Applies only to REQUIRED or REQUIRES_NEW.                                                                                                                                                                  |
| rollback-for    | no        |          | Comma-delimited list of Exception instances that trigger rollback. For example, com.foo.MyBusinessException,ServletException.                                                                                                                       |
| no-rollback-for | no        |          | Comma-delimited list of Exception instances that do not trigger rollback. For example, com.foo.MyBusinessException,ServletException.                                                                                                                |



### 1.4.6. 使用`@Transactional`

除了基于XML的声明式事务配置，也可以使用基于注解的事务配置。直接在Java源码中声明事务语义会使声明更加接近受影响的代码。不存在过度耦合的危险，因为原本打算以事务方式使用的代码几乎总是以这种方式部署。



使用`@Transactional`注解提供的易用性将通过一个示例得到最好的说明：

```java
// the service class that we want to make transactional
@Transactional
public class DefaultFooService implements FooService {

    Foo getFoo(String fooName) {
        // ...
    }

    Foo getFoo(String fooName, String barName) {
        // ...
    }

    void insertFoo(Foo foo) {
        // ...
    }

    void updateFoo(Foo foo) {
        // ...
    }
}
```

 如上所述，在类级别使用注解，为声明类(及其子类)的所有方法指明了一个默认值。另外，每个方法可以单独注解。注意，类级别注解不适用于类层次结构中的祖先类。在这种情况下，需要在本地重新声明方法，以参与子类级别的注解。



当在Spring上下问中有一个POJO类像上面定义的那样，可以通过在`@Configuration`类加入`@EnableTransactionManagement`注解使bean实例具有事务性。



在XML配置中，`<tx:annotaion-driven/>`标签提供相似的功能：

```xml
<!-- from the file 'context.xml' -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- this is the service object that we want to make transactional -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- enable the configuration of transactional behavior based on annotations -->
    <tx:annotation-driven transaction-manager="txManager"/><!-- a TransactionManager is still required --> 

    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- (this dependency is defined somewhere else) -->
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- other <bean/> definitions here -->

</beans>
```

> **方法可见性和`@Transactional`**
> 
> 当使用代理时，应该仅在公共的可见方法上使用`@Transactional`注解。如果在protected、private或包可见方法上使用该注解，不会产生错误，但是带注解的方法不会显示已配置的事务设置。如果需要注解一个非public方法，考虑使用AspectJ。



可以将`@Transactional`注解应用与接口定义，接口的方法、类定义、或类中的public方法。但是，仅`Transactional`注解的存在不足以激活事务行为。该注解仅仅是元数据，可以被某些支持`@Transactional`的运行时基础数据结构使用，并且可以使用元数据配置具有事务行为的适当的bean。在前面的例子中，`<tx:annotation-driven/>`元素用来切换事务行为。

> 建议仅在具体类上使用该注解，而不是接口。当然可以在接口上放置该注解，但这仅在使用基于接口的代理时才可以预期地起作用。Java注解的事实并不意味着继承接口,如果使用基于类的代理(proxy-target-class = " true ")或weaving-based切面(mode=“aspectj”),事务设置不认可的代理和编织的基础设施,和对象不是包装在一个事务代理。



> 在代理模式（默认）下，仅拦截通过代理传入的外部方法调用。这意味着自调用（实际上）不会在运行时导致实际事务。此外，代理必须完全初始化才能提供预期的行为，因此不应该在初始化代码中依赖此特性(即@PostConstruct)。



如果希望自调用也被包装到事务中，可以考虑使用AspectJ模式。在这种情况下，首先没有代理。而是编织目标类（即修改其字节码）将`@Transactional`转换为任意方法上的运行时行为。

| XML Attribute       | Annotation Attribute                              | Default                   | Desctiption                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ------------------- | ------------------------------------------------- | ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| transaction-manager | N/A (see TransactionManagementConfigurer javadoc) | transactionManager        | Name of the transaction manager to use. Required only if the name of the transaction manager is not transactionManager, as in the preceding example.                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| mode                | mode                                              | proxy                     | The default mode (proxy) processes annotated beans to be proxied by using Spring’s AOP framework (following proxy semantics, as discussed earlier, applying to method calls coming in through the proxy only). The alternative mode (aspectj) instead weaves the affected classes with Spring’s AspectJ transaction aspect, modifying the target class byte code to apply to any kind of method call. AspectJ weaving requires spring-aspects.jar in the classpath as well as having load-time weaving (or compile-time weaving) enabled. (See Spring configuration for details on how to set up load-time weaving.) |
| proxy-target-class  | proxyTargetClass                                  | false                     | Applies to proxy mode only. Controls what type of transactional proxies are created for classes annotated with the @Transactional annotation. If the proxy-target-class attribute is set to true, class-based proxies are created. If proxy-target-class is false or if the attribute is omitted, then standard JDK interface-based proxies are created. (See Proxying Mechanisms for a detailed examination of the different proxy types.)                                                                                                                                                                          |
| order               | order                                             | Ordered.LOWEST_PRECEDENCE | Defines the order of the transaction advice that is applied to beans annotated with @Transactional. (For more information about the rules related to ordering of AOP advice, see Advice Ordering.) No specified ordering means that the AOP subsystem determines the order of the advice.                                                                                                                                                                                                                                                                                                                            |



> 处理`@Transactional`注解的默认通知模式是`proxy`，它允许仅通过代理来拦截调用。同一类内的本地调用无法以这种方式被拦截。对于更高级的拦截模式，请考虑使用编译时或加载时编织切换到AspectJ模式。



> `proxy-target-class`属性控制为使用`@Transactional`注解的类创建哪种类型的事务代理。如果设置为`true`，基于类的代理被创建。如果设置为`false`或被省略，会创建基于标准JDK接口的代理。



> `EnableTransactionManagement`和`<tx:annotation-driven/>`仅在定义他们的相同应用程序上下文中的bean上查找`@Transactional`。这意味着，如果将注解驱动配置在`DispatcherServlet`的`WebApplicationContext`中，它将仅在控制器而不是服务中检查`@Transactional`。



 在计算方法的事务设置时，派生程度最高的位置优先。在以下实例的情况下，`DefaultFooService`类注解了类级别的只读事务设置，但是注解在方法`updateFoo(Foo)`上的优先级要高于类上的注解事务设置。

```java
@Transactional(readOnly = true)
public class DefaultFooService implements FooService {

    public Foo getFoo(String fooName) {
        // ...
    }

    // these settings have precedence for this method
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    public void updateFoo(Foo foo) {
        // ...
    }
}
```



**@Transactional 设置**

该注解是元数据用来指定接口，类或方法必须拥有事务性语义（例如，当方法被调用时，开始一个全新的只读事务，挂起任何已存在的事务）。默认的`@Transactional`设置如下：

* 传播性设置为：`PROPAGATION_REQUIRED`。

* 隔离级别为：`ISOLATION_DEFAULT`。

* 事务为读写事务。

* 事务超时默认为基础事务系统的默认超时，如果不支持超时，则默认为无。

* 任何`RuntimeException`触发回滚，任何已检查异常不会。



可以改变默认设置。下面的表格总结了`@Transactional`注解的多种属性：

| Property               | Type                                                                        | Description                                                                                                                |
| ---------------------- | --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| value                  | String                                                                      | Optional qualifier that specifies the transaction manager to be used.                                                      |
| propagation            | enum: Propagation                                                           |                                                                                                                            |
| isolation              | enum: Isolation                                                             | Optional isolation level. Applies only to propagation values of REQUIRED or REQUIRES_NEW.                                  |
| timeout                | int (in seconds of granularity)                                             | Optional transaction timeout. Applies only to propagation values of REQUIRED or REQUIRES_NEW.                              |
| readOnly               | boolean                                                                     | Read-write versus read-only transaction. Only applicable to values of REQUIRED or REQUIRES_NEW.                            |
| rollbackFor            | Array of Class objects, which must be derived from Throwable.               | Optional array of exception classes that must cause rollback.                                                              |
| rollbackForClassName   | Array of class names. The classes must be derived from Throwable.           | Optional array of names of exception classes that must cause rollback.                                                     |
| noRollbackFor          | Array of Class objects, which must be derived from Throwable.               | Optional array of exception classes that must not cause rollback.                                                          |
| noRollbackForClassName | Array of String class names, which must be derived from Throwable.          | Optional array of names of exception classes that must not cause rollback.                                                 |
| label                  | Array of String labels to add an expressive description to the transaction. | Labels may be evaluated by transaction managers to associate implementation-specific behavior with the actual transaction. |



目前，无法对事务名称进行显示控制，其中名称表示在事务监视器（如果使用）（例如WebLogic的事务监视器）和日志输出中显示的事务名称。对于声明式事务，事务名称始终是全限定类名+`.`+事务通知类的方法名称。例如，如果`BusinessService`类中的`handlePayment(...)`方法开始一个事务，name事务的名称为：`com.example.BusinessService.handlePayment`。



**使用`@Transactional`进行多事务管理**

绝大多数Spirng应用程序仅需要一个事务管理器，但是仍然有一些场景需要在单个应用程序中使用多个独立的事务管理器。可以使用`@Transactional`的`value`或`transactionManager`属性来指定表示要使用的`TransactionManager`。他们可以是bean名称或者是事务管理器bean的限定符值。例如，使用限定符，可以在应用程序上下文中将以下Java打码与以下事务管理器bean声明进行组合：

```java
public class TransactionalService {

    @Transactional("order")
    public void setSomething(String name) { ... }

    @Transactional("account")
    public void doSomething() { ... }

    @Transactional("reactive-account")
    public Mono<Void> doSomethingReactive() { ... }
}
```

下面列出了bean声明：

```xml
<tx:annotation-driven/>

    <bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        ...
        <qualifier value="order"/>
    </bean>

    <bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        ...
        <qualifier value="account"/>
    </bean>

    <bean id="transactionManager3" class="org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager">
        ...
        <qualifier value="reactive-account"/>
    </bean>
```

在这个例子中，`TransactionalService`上的独立方法运行在分割的事务管理器下，通过不同的`order`，`account`和`reactive-acount`限定符。如果未找到特别限定的`TransactionManager` bean，则仍使用默认的`<tx:annotation-driven>`目标bean名称`transactionManager`。



**自定义组合注解**

如果发现使用了相同的`@Transactional`在不同的方法上，Spring元注解可以为特殊用例定义自定义组合注解。例如，思考下面的注解定义：

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional(transactionManager = "order", label = "causal-consistency")
public @interface OrderTx {
}

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional(transactionManager = "account", label = "retryable")
public @interface AccountTx {
}
```

```java
public class TransactionalService {

    @OrderTx
    public void setSomething(String name) {
        // ...
    }

    @AccountTx
    public void doSomething() {
        // ...
    }
}
```

在前面的例子中，使用语法来定义事务管理器限定符和事务性标签，但是也可以包含传播行为，回滚规则，超时和其他功能。



### 1.4.7. 事务传播

本节描述了Spring中的一些事务传播语义。注意，本节不是用来介绍事务传播的，而是详细介绍了有关Spring中事务传播的一些语义。



在Spring管理的事务中，注意物理事务和逻辑事务之间的区别，以及传播设置如何应用于此区别。



**理解`PROPAGATION_REQUIRED`**

![](https://raw.githubusercontent.com/Aris4009/attachment/main/20210119174540.png)

`PROPAGATION_REQUIRED`强制执行物理事务，如果还没有事务存在，则为当前范围在本地执行，或者参与为更大范围定义的现有“外部”事务。这是同一线程中常见的调用堆栈安排中的默认设置（例如，一个服务外观，委派给集中存储库方法，其中，所有基础资源都必须参与服务及事务）。



> 默认情况下，参与的事务将加入外部作用域的特征，而忽略本地隔离级别，超时值或只读标记。如果要在参与具有不同隔离级别的现有事务时拒绝隔离级别声明，请考虑在事务管理器上将`validateExsitingTransations`标志设置为`true`。这种非宽容模式还拒绝只读不匹配（即，内部读写事务视图参与只读外部作用域）。



当传播行为设置为`PROPAGATION_REQUIRED`时，将为应用该设置的每种方法创建一个逻辑事务作用域。每个逻辑事务范围可以独立决定回滚状态，而外部事务作用域在逻辑上独立于内部事务作用域。对于标准`PROPAGATION_REQUIRED`行为，所有这些范围都映射到同一物理事务。因此，内部事务范围中设置的回滚标记确实会影响外部事务实际提交的机会。



但是，在内部事务范围仅设置回滚标记的情况下，外部事务尚未决定回滚本身，因此，回滚是意外的（由内部事务静默触发）。此时，将引发相应的`UnexpectedRollbackException`。这是预期的行为，因此决不能误导事务的调用方以假设在缺失未执行提交的情况下执行该提交。因此，如果内部事务（外部调用者不知道）将一个事务无提示的标记为仅回滚，则外部调用者仍会调用commit。外部调用者需要接受一个`UnexpectedRollbackException`，以清除的指示已执行回滚。



**理解`PROPAGATION_REQUIRED_NEW`**

![](https://raw.githubusercontent.com/Aris4009/attachment/main/20210119180226.png)

`PROPAGATION_REQUIRED_NEW`与`PROPAGATION_REQUIRED`相比，总是为每个受影响的事务范围使用一个独立的物理事务，绝不会参与外部已存在的事务。在这样的安排下，底层资源事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务回滚状态的影响，内部事务完成后立即释放锁。这样的独立内部事务还可以声明其自己的隔离级别，超时和只读设置，而不会继承外部事务的特征。



**理解`PROPAGATION_NESTED`**

`PROPAGATION_NESTED`使用具有多个savepoints的单独的物理事务以便用来回滚。这种部分回滚使内部事务范围触发其范围的回滚，尽管某些操作已回滚，但外部事务仍能够继续物理事务。此设置通常映射到JDBC的savepoints，因此仅适用于JDBC资源事务。



### 1.4.8. 通知事务操作

假设想要运行事务操作和一些基础的分析通知，如何在`<tx:annotation-driven/>`的上下文中实现此目的？



当调用`updateFoo(Foo)`方法时，想要看见下面的动作：

* 配置的分析切面开始。

* 事务通知运行。

* 在被通知的对象上运行。

* 事务提交。

* 分析切面，报告整个事务方法调用的确切持续时间。



下面的代码展示了之前讨论的简单分析切面：

```java
package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;
import org.springframework.core.Ordered;

public class SimpleProfiler implements Ordered {

    private int order;

    // allows us to control the ordering of advice
    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    // this method is the around advice
    public Object profile(ProceedingJoinPoint call) throws Throwable {
        Object returnValue;
        StopWatch clock = new StopWatch(getClass().getName());
        try {
            clock.start(call.toShortString());
            returnValue = call.proceed();
        } finally {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
        return returnValue;
    }
}
```



通知的顺序通过`Ordered`接口控制。



下面的配置创建了一个`fooService` bean，它以所需的顺序应用了分析和事务方面:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- this is the aspect -->
    <bean id="profiler" class="x.y.SimpleProfiler">
        <!-- run before the transactional advice (hence the lower order number) -->
        <property name="order" value="1"/>
    </bean>

    <tx:annotation-driven transaction-manager="txManager" order="200"/>

    <aop:config>
            <!-- this advice runs around the transactional advice -->
            <aop:aspect id="profilingAspect" ref="profiler">
                <aop:pointcut id="serviceMethodWithReturnValue"
                        expression="execution(!void x.y..*Service.*(..))"/>
                <aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
            </aop:aspect>
    </aop:config>

    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
        <property name="username" value="scott"/>
        <property name="password" value="tiger"/>
    </bean>

    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

</beans>
```

可以以这种相似的方式增加任意数量的切面。



下面的例子展示了相同的设置但是使用了纯XML声明方式：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- the profiling advice -->
    <bean id="profiler" class="x.y.SimpleProfiler">
        <!-- run before the transactional advice (hence the lower order number) -->
        <property name="order" value="1"/>
    </bean>

    <aop:config>
        <aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/>
        <!-- runs after the profiling advice (c.f. the order attribute) -->

        <aop:advisor advice-ref="txAdvice" pointcut-ref="entryPointMethod" order="2"/>
        <!-- order value is higher than the profiling aspect -->

        <aop:aspect id="profilingAspect" ref="profiler">
            <aop:pointcut id="serviceMethodWithReturnValue"
                    expression="execution(!void x.y..*Service.*(..))"/>
            <aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
        </aop:aspect>

    </aop:config>

    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!-- other <bean/> definitions such as a DataSource and a TransactionManager here -->

</beans>
```

前面的配置的结果是一个`fooService` bean依次具有分析和事务切面的内容。可以交换order属性值，来达到不同的效果。



### 1.4.9. 通过AspectJ使用`@Transactional`

还可以使用通过AspectJ切面，在Spring容器之外使用Spring框架的`@Transactional`支持。为此，首先使用`@Transactional`注解对类进行注解。然后，将应用程序与`spring-aspectj.jar`文件中定义的`org.springframework.transaction.aspectj.AnnotationTransactionAspect`连接（编织）。还必须使用事务管理器配置切面。可以使用Spring框架的IoC容器来处理依赖注入切面。配置事务管理切面的最简单方法是使用`<tx:annotation-driven/>`元素，并为`aspectj`指定`mode`。因为这里专注于在Spring容器之外运行的应用程序，所以展示如何以编程方式进行操作。



下面的例子展示了如何创建一个事务管理器并配置`AnnotationTransactionAspect`来使用：

```java
// construct an appropriate transaction manager
DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());

// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods
AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);
```

> 当使用这个切面时，需要注解实现类（或类的方法或两者），不要该类实现的接口。AspectJ遵循Java的规则，即不继承接口上的注释。



类上的@Transactional注释指定用于执行该类中任何公共方法的默认事务语义。



类中方法上的@Transactional注释将覆盖类注释（如果存在）给出的默认事务语义。您可以注释任何方法，而不管可见性如何。



要使用AnnotationTransactionAspect编织应用程序，必须使用AspectJ构建应用程序（请参阅AspectJ开发指南）或使用加载时编织。



## 1.5. 编程式事务管理

Spring框架提供两种编程式事务管理的方法：

* `TransactionTemplate`或`TransactionalOperator`

* `TrransactionManager`的直接实现

Spring建议对命令性流程中的编程式事务管理使用`TransactionTemplate`，对于反应式编程使用`TransactionalOperator`。第二种方式与使用JTP中的`UserTransaction`API类似，尽管异常处理很麻烦。



### 1.5.1. 使用`TransactionTemplate`

`TransactionTemplate`采用与Spring模板相同的方法，例如`JdbcTemplate`。它使用回调方法（使应用程序代码不必进行样板获取和释放事务性资源），并生成意向驱动的代码，因为这样的代码仅需要专注于要执行的操作。

> 像下面的例子展示的那样，使用`TransactionTemplate`绝对会将代码与Spring的事务基础设施和API耦合。编程式事务管理是否符合开发需求必须要用户自己来做决定。



应用程序代码必须运行在事务上下文中并且像下面的例子一样明确地使用`TransactionTemplate`。作为应用程序开发者，可以编写`TransactionCallback`的实现（通常表示为匿名内部类），它包含了需要在事务上下文中运行的代码。然后，可以将自定义的`TransactionCallback`实例传递给`TransactionTemplate`上公开的`execute(..)`方法。下面的例子展示了如何实现这样的代码：

```java
public class SimpleService implements Service {

    // single TransactionTemplate shared amongst all methods in this instance
    private final TransactionTemplate transactionTemplate;

    // use constructor-injection to supply the PlatformTransactionManager
    public SimpleService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public Object someServiceMethod() {
        return transactionTemplate.execute(new TransactionCallback() {
            // the code in this method runs in a transactional context
            public Object doInTransaction(TransactionStatus status) {
                updateOperation1();
                return resultOfUpdateOperation2();
            }
        });
    }
}
```

如果没有返回值，也可以使用渐变的`TransactionCallbackWithoutResult`类：

```java
transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});
```

带有回调的代码也可以通过调用`TransactionStatus`对象上的`setRollbackOnly()`方法来支持事务回滚：

```java
transactionTemplate.execute(new TransactionCallbackWithoutResult() {

    protected void doInTransactionWithoutResult(TransactionStatus status) {
        try {
            updateOperation1();
            updateOperation2();
        } catch (SomeBusinessException ex) {
            status.setRollbackOnly();
        }
    }
});
```



**指定事务设置**

无论使用编程式还是配置，都可以在`TransactionTemplate`上可以指定事务设置（例如传播模式，隔离级别，超时等等）。默认情况下，`TransactionTemplate`实例拥有默认的事务性设置。下面的例子展示了指定自定义的事务性设置：

```java
public class SimpleService implements Service {

    private final TransactionTemplate transactionTemplate;

    public SimpleService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);

        // the transaction settings can be set here explicitly if so desired
        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
        this.transactionTemplate.setTimeout(30); // 30 seconds
        // and so forth...
    }
}
```

下面的例子展示了使用XML配置为`TransactionTemplate`指定自定义的设置：

```xml
<bean id="sharedTransactionTemplate"
        class="org.springframework.transaction.support.TransactionTemplate">
    <property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/>
    <property name="timeout" value="30"/>
</bean>
```

可以在需要的时候为多个services注入`sharedTransactionTemplate`。



最后，`TransactionTemplate`类是线程安全的，它的实例不维护任何会话状态。然而，`TransactionTemplate`实例仍然保持配置状态。因此，虽然许多类可以共享一个单独的实例，但是如果需要使用不同设置的`TransactionTemplate`，需要创建两个不同的实例。



### 1.5.2. 使用`TransactionOperator`（略...）

### 1.5.3. 使用`TransactionManager`

接下来的部分将要解释命令式和反应式事务管理的编程用法。



**使用`PlatformTransactionManager`**

对于命令式事务，可以直接使用`org.springframework.transaction.PlatformTransactionManager`来管理事务。为此，通过bean引用为bean传递`PlatformTransactionManager`的实现。然后，通过使用`TransactionDefinition`和`TransactionStatus`对象，可以初始化事务、回滚和提交。下面的例子展示了怎么做：

```java
DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    // put your business logic here
}
catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);
```

**使用`ReactiveTransactionManager`（略...）**



## 1.6.






