# 3. 使用JDBC来进行数据访问

下表中概述的操作顺序可能最好地显示了Spring Framework JDBC抽象提供的价值。该表显示了Spring负责哪些操作，哪些操作是用户的责任。

| Action          | Spring | You |
| --------------- | ------ | --- |
| 定义链接参数          |        | x   |
| 打开链接            | x      |     |
| 定义SQL语句         |        | x   |
| 声明参数和提供参数值      |        | x   |
| 准备和运行语句         | x      |     |
| 设置循环来遍历结果（如果存在） | x      |     |
| 为每个迭代做其他工作      |        | x   |
| 处理任何异常          | x      |     |
| 处理事务            | x      |     |
| 关闭链接，语句和结果集     | x      |     |

Spring框架负责所有可能使JDBC成为乏味的API的低级细节。



## 3.1. 为JDBC数据库访问选择方法

可以选择几种方法来构成JDBC数据库访问的基础。除了`JdbcTemplate`的三种形式之外，新的`SimpleJdbcCall`和`SimpleJdbcInsert`方法还优化了数据库元数据，并且RDBMS对象样式采用了一种类似于JDO设计的面向对象方法。一旦开始使用其中的一种，仍然能混合搭配以包含来自其他方法的功能。所有方法需要兼容JDBC 2.0的驱动陈瑞供需，某些高级功能需要JDBC 3.0驱动程序。

* `JdbcTemplate`是经典最流行的Spring JDBC方法。这种低级别的方法及所有其他方法都在后台使用了JdbcTemplate。

* `NamedParameterJdbcTemplate`包装了一个`JdbcTemplate`来提供命名参数代替传统JDBC中的`?`占位符。当SQL语句有多个参数时，这个方法提供了更好的文档编制和易于性。

* `SimpleJdbcInsert`和`SimpleJdbcCall`优化数据库元数据来限制必要的配置量。这种方法简化了编码，因此只要提供表或存储过程名称，并提供匹配的参数映射即可。它仅在数据库提供足够的元数据时才有效。如果数据库不能提供这些元数据，必须提供明确的参数配置。

* RDBMS对象-包括`MappingSqlQuery`，`SqlUpdate`和`StoredProcedure`要求创建可重用的线程安全的对象在初始化数据访问层时。这个方法以JDO Query为模型，其中定义查询字符串，声明参数并编译查询。一旦这样做后，`execute(...)`，`update(...)`和`findObject(...)`方法可以通过多种参数被调用。



## 3.2. 包层次结构

Spring框架的JDBC抽象框架包含四种不同的包：

* `core`：`org.springframework.jdbc.core`包包含了`JdbcTemplate`类和它的多种回调接口，加上各种相关的类。名为`org.springframework.jdbc.core.simple`包含`SimpleJdbcInsert`和`SimpleJdbcCall`类。其他名为`org.springframework.jdbc.core.nameparam`的子包包含`NamedParameterJdbcTemplate`类和相关支持的类。

* `datasource`：`org.springframework.jdbc.datasource`包包含易于`DataSource`访问的工具类和多种简单`DataSource`实现，可以在Java EE容器之外测试和运行未修改的JDBC代码。

* `object`：`org.springframework.jdbc.object`包包含的类表示RDBMS查询，更新和线程安全的存储过程，可重用的对象。

* `support`：`org.springframework.jdbc.support`包提供了`SQLException`转换功能和一些工具类。在JDBC处理期间抛出的异常会被翻译为定义在`org.springframework.dao`包中的异常定义。这以为这使用Spring JDBC抽象层不需要实现JDBC或特殊的RDBMS错误控制。所有翻译的异常是未检查异常，可以选择捕获这些异常来恢复，同事将其他异常传播到调用方。



## 3.3. 使用JDBC核心类来控制基本JDBC处理和异常处理

本节涵盖了如何使用JDBC核心类来控制基础JDBC处理，包含错误处理。它包含如下主题：

* 使用`JdbcTemplate`

* 使用`NamedParameterJdbcTemplate`

* 使用`SQLExceptionTranslator`

* 运行语句

* 运行查询

* 更新数据库

* 获取自增主键

### 3.3.1. 使用`JdbcTemplate`

在JDBC核心保重，`JdbcTemplate`是中心类。它处理创建和释放资源，可以帮助用户避免常见错误，例如忘记关闭链接。它执行核心JDBC工作流的基本任务（例如语句创建和执行），留下应用程序代码以提供SQL并提取结果：

* 返回SQL查询结果

* 更新语句和存储过程调用

* 执行`ResultSet`实例迭代并且提取返回参数值。

* 捕获JDBC异常，并且将他们翻译为通用的信息量更大的异常，异常层次结构定义在`org.springframework.dao`包中



当代码使用`JdbcTemplate`是，仅需要实现回调接口，给他们一个明确清洗的定义。`JdbcTemplate`提供指定的`Connection`，`PreparedStatementCreator`回调接口创建一个prepared语句，提供SQL和必要的参数。对于`CallableStatementCreator`接口也是如此，它创建了回调语句。`RowCallbackHandler`接口从`ResultSet`的每行中提取值。



通过直接实例化的`DataSource`引用，在DAO实现中使用`JdbcTemplate`或在Spring IoC容器中配置，并且将它设置给DAO的引用。

> `DataSource`应该总是配置在Spring IoC容器中。在第一种情况下，将Bean直接提供给服务。在第二种情况下，将其提供给准备好的模板。



通过这个类发出的SQL君在`DEBUG`级别下记录，该类别对应于模板实例的完全限定的类名称（通常是`JdbcTemplate`，但是它可能是不同的自定义的`JdbcTemplate`类的子类）。



下面的部分提供一些`JdbcTemplate`的使用案例。这些例子不是`JdbcTemplate`公开的所有功能的详尽列表。



**查询（`SELECT`）**

下面的查询获取关系中的行数：

```java
int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class);
```



绑定变量查询：

```java
int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(
        "select count(*) from t_actor where first_name = ?", Integer.class, "Joe");
```



查询字符串：

```java
String lastName = this.jdbcTemplate.queryForObject(
        "select last_name from t_actor where id = ?",
        String.class, 1212L);
```



查找并填充单个领域对象：

```java
Actor actor = jdbcTemplate.queryForObject(
        "select first_name, last_name from t_actor where id = ?",
        (resultSet, rowNum) -> {
            Actor newActor = new Actor();
            newActor.setFirstName(resultSet.getString("first_name"));
            newActor.setLastName(resultSet.getString("last_name"));
            return newActor;
        },
        1212L);
```



查找并填充领域对象列表：

```java
List<Actor> actors = this.jdbcTemplate.query(
        "select first_name, last_name from t_actor",
        (resultSet, rowNum) -> {
            Actor actor = new Actor();
            actor.setFirstName(resultSet.getString("first_name"));
            actor.setLastName(resultSet.getString("last_name"));
            return actor;
        });
```



如果最后两个代码片段确实存在于相同的应用程序，它可能是有意义的，因为溢出了存在与两个`RowMapper` lambda表达式中的重复代码，并且将他们提取到单独的字段外然后通过DAO方法在需要的时候引用。例如，下面的例子可能比之前的代码片段更好：

```java
private final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> {
    Actor actor = new Actor();
    actor.setFirstName(resultSet.getString("first_name"));
    actor.setLastName(resultSet.getString("last_name"));
    return actor;
};


public List<Actor> findAllActors() {
    return this.jdbcTemplate.query( "select first_name, last_name from t_actor", actorRowMapper);
}
```



**使用`JdbcTemplate`更新（`INSERT`，`UPDATE`，`DELETE`）**

可以使用`update(..)`方法来执行插入，更新和删除操作。参数值通常作为变量参数提供，或者作为对象数组。



下面的例子插入了一个新的实体：

```java
this.jdbcTemplate.update(
        "insert into t_actor (first_name, last_name) values (?, ?)",
        "Leonor", "Watling");
```



下面的例子更新了一个实体：

```java
this.jdbcTemplate.update(
        "update t_actor set last_name = ? where id = ?",
        "Banjo", 5276L);
```



下面的例子删除了一个实体：

```java
this.jdbcTemplate.update(
        "delete from t_actor where id = ?",
        Long.valueOf(actorId));
```



**其他`JdbcTemplate`操作**

可以使用`execute(..)`方法来运行任何SQL。因此，它通常被用来执行DDL语句。 它由接受回调接口、绑定变量数组等的变量重载。下面的例子展示了创建一个table：

```java
this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
```



下面的例子是调用存储过程：

```java
this.jdbcTemplate.update(
        "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
        Long.valueOf(unionId));
```

更多复杂存储过程支持请参考 [covered later](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-StoredProcedure)。



**`JdbcTemplate` 最佳实践**

`JdbcTemplate`类的实例是线程安全的。这非常重要，因为这已维护者可以配置一个独立的实例，然后安全的注入到多个DAOs中共享此引用。`JdbcTemplate`是有状态的，它维护了一个`DataSource`的引用，但是这个状态不是会话状态。[Thread safety - Wikipedia](https://en.wikipedia.org/wiki/Thread_safety)



当使用`JdbcTemplate`类（和相关的`NamedParameterJdbcTemplate`类），常见的实践是在Spring配置文件中配置一个`DataSource`，将共享的`DataSource` bean注入到DAO类中。`JdbcTemplate`通过setter方法设置`DataSource`。这会导致类似下面这样的DAOs：

```java
public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}
```

下面是相应的XML配置文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <context:property-placeholder location="jdbc.properties"/>

</beans>
```



另外，也可以使用组件扫描和依赖注入的注解支持来明确配置这样，可以将类与`@Repository`注解结合，使用带有`@Autowired`注解的setter方法将`DataSource`注入：

```java
@Repository 1 
public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    @Autowired 2
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource); 3 
    }

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}
```



<mark>1. 使用`@Repository`注解类</mark>

<mark>2. 使用带有`@Autowired`注解的方法设置`DataSource`</mark>

<mark>3. 通过`DataSource`创建一个新的对象</mark>



下面的例子展示了相应的配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- Scans within the base package of the application for @Component classes to configure as beans -->
    <context:component-scan base-package="org.springframework.docs.test" />

    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <context:property-placeholder location="jdbc.properties"/>

</beans>
```



如果使用Spring的`JdbcDaoSupport`类和多种从它扩展的JDBC支持的DAO类，子类从`JdbcDaoSupport`继承了`setDataSource(...)`方法。可以选择是否从这个类继承。`JdbcDaoSupport`类只是为了提供方便。



无论使用以上哪种模板初始化样式，每次运行SQL时，都几乎不必创建`JdbcTemplate`类的新实例。一旦配置了，`JdbcTemplate`实例是线程安全的。如果应用程序需要访问多个数据库，可能会需要多个实例。



### 3.3.2. 使用`NamedParameterJdbcTemplate`

`NamedParameterJdbcTemplate`类为JDBC编程增加了命名参数支持来代替经典的（`'?'`）占位符。它包装了一个`JdbcTemplate`，并委托给包装的`JdbcTemplate`来工作。本节仅描述它与`JdbcTemplate`本身的区别--通过使用命名的参数来进行JDBC语句编程。下面例子展示了如何使用它：

```java
// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
```



注意，在分配给sql变量的值和插入到namedParameters变量(类型为MapSqlParameterSource)的相应值中使用了命名参数表示法。



另外，可以传递基于`Map`样式的命名参数给`NamedParameterJdbcTemplate`实例。由`NamedParameterJdbcOperations`公开并由`NamedParameterJdbcTemplate`类实现的其余方法都遵循类似的模式，此处不再赘述。



下面展示了使用基于`Map`样式的例子：

```java
// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    Map<String, String> namedParameters = Collections.singletonMap("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters,  Integer.class);
}
```



`SqlparameterSource`接口是与`NamedParameterJdbcTemplate`相关的一个不错功能。已经在之前的代码片段中看到了此接口的实现示例。`SqlParamterSource`是`NamedParameterdbcTemplate`的命名参数值的源。`MapSqlParameterSource`类是它的简单实现，可以适配包装一个`java.util.Map`，key为参数名，值为参数值的键值对。



另一个`SqlParameterSource`实现是`BeanPropertySqlParameterSource`类。这个类可以包装任意JavaBean（也就是说，也就是遵循JavaBean约定的类的实例），并且包装的JavaBean的属性作为命名参数值的源。



下面的例子展示了常用的JavaBean：

```java
public class Actor {

    private Long id;
    private String firstName;
    private String lastName;

    public String getFirstName() {
        return this.firstName;
    }

    public String getLastName() {
        return this.lastName;
    }

    public Long getId() {
        return this.id;
    }

    // setters omitted...

}
```



下面的例子使用`NamedParameterJdbcTemplate`，展示之前例子中的类返回的数量：

```java
// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActors(Actor exampleActor) {

    // notice how the named parameters match the properties of the above 'Actor' class
    String sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName";

    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
```

记住，`NamedParameterJdbcTemplate`类包装了经典的`JdbcTemplate`模板。如果需要访问一个包装的`JdbcTemplate`实例来访问仅在`JdbcTemplate`类中提供的功能，则可以使用`getJdbcOperations()`方法，通过`JdbcOperations`接口访问包装的`JdbcTemplate`。



### 3.3.3 使用`SQLExceptionTranslator`

`SQLExceptionTranslator`是一个接口，通过它来实现`SQLException`与Spring自身的`org.springframework.dao.DataAccessException`之间的转换，这与数据访问策略无关。为了提高精度，实现可以是通用的（例如，对于JDBC，使用`SQLState`代码）或专有的（例如，使用Oracle错误代码）。



`SQLErrorCodeSQLExceptionTranslator`是`SQLExceptionTranslator`的默认实现。该实现使用特定的代码。它比`SQLState`实现更精确。错误代码转换基于保存在名为SQLErrorCodes的JavaBean类型类中的代码。这个类通过`SQLErrorCodesFactory`来创建和填充，`SQLErrorCodesFactory`是创建`SQLErrorCodes`的工厂，它用于根据名为`sql-error-codes.xml`的配置文件内容创建`SQLErrorCodes`。该文件使用供应商代码填充，并基于`DatabaseMetaData`中获取的`DatabaseProductName`填充。使用正在使用的实际数据库的代码。



`SQLErrorCodeSQLExceptionTranslator`应用匹配的规则顺序如下：

1. 通过子类实现的任何自定义转换。通常，提供具体的`SQLErrorCodeSQLExceptionTranslator`来使用，这个规则不会应用。如果实际提供了子类实现，仅应用这个实现。

2. `SQLExceptionTrranslator`接口的任意自定义实现，作为`SQLErrorCodes`类的`customSqlExceptionTranslator`属性被提供。

3. `CustomSQLErrorCodesTranslation`类的实例列表，通过检索来匹配。

4. 应用错误代码匹配

5. 使用备选转换器。`SQLExceptionSubclassTranslator`是默认的备选转换器。如果此转换器不可用，接下来的备选转换器是`SQLStateSQLExceptionTranslator`。



可以扩展`SQLErrorCodeSQLExceptionTranslator`：

```java
public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

    protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) {
        if (sqlEx.getErrorCode() == -12345) {
            return new DeadlockLoserDataAccessException(task, sqlEx);
        }
        return null;
    }
}
```

在之前的例子中，特殊的错误代码（`-12345`）被转换，而其他错误则由默认转换器实现转换。为了使用自定义转换器，必须通过`setExceptionTranslator`方法将其传递给`JdbcTemplate`，并且必须使用它来处理所有数据访问。下面的例子展示了如何使用自定义转换器：

```java
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {

    // create a JdbcTemplate and set data source
    this.jdbcTemplate = new JdbcTemplate();
    this.jdbcTemplate.setDataSource(dataSource);

    // create a custom translator and set the DataSource for the default translation lookup
    CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();
    tr.setDataSource(dataSource);
    this.jdbcTemplate.setExceptionTranslator(tr);

}

public void updateShippingCharge(long orderId, long pct) {
    // use the prepared JdbcTemplate for this update
    this.jdbcTemplate.update("update orders" +
        " set shipping_charge = shipping_charge * ? / 100" +
        " where id = ?", pct, orderId);
}
```

定制转换器会传递一个数据源，以便在sql-error-codes.xml中查找错误代码。



### 3.3.4. 运行语句


